#ifndef _GENETIC_GENETIC_ALGORITHM_INCLUDED
#define _GENETIC_GENETIC_ALGORITHM_INCLUDED

/**
* @author Manwe
*
*    Class providing an implementation of a genetic algorithm.
*
* @see <a href="https://en.wikipedia.org/wiki/Genetic_algorithm">Genetic algorithm</a>
*
* @param <Genotype>
*     The class representing one candidate
*/

#include <random>
#include <algorithm>
#include <functional>
#include <list>
#include <map>
#include <memory>

namespace competitive{
namespace programming{
namespace genetic{
	template<typename Genotype>
	class GeneticAlgorithm {
	public:
		typedef std::map<std::shared_ptr<Genotype>, double> GenotypeScoreMap;
	public:
		/**
		* Constructor
		*
		* @param fitnessFunction
		*		Evaluate a candidate. During the selection phase, only the candidates with the highest score will be retained
		*       return the double value representing the quality of a candidate. The higher the better.
		* @param generator
		*		an implementation of a generator in charge of randomly generating new candidates
		* @param merger
		*		an implementation of a merger in charge of creating a new genotype from two already existing genotype
		* @param mutator
		*		an implementation of a mutator in charge of creating a new genotype from an existing genotype but modifying some characteristics
		*/
		GeneticAlgorithm(
			std::function<double(const Genotype&)> fitnessFunction,
			std::function<Genotype()> generator,
			std::function<Genotype(const Genotype&, const Genotype&)> merger,
			std::function<Genotype(const Genotype&)> mutator) :

			m_fitnessFunction(fitnessFunction),
			m_generator(generator),
			m_merger(merger),
			m_mutator(mutator),
			m_cachedScores(),
			m_candidates(),
			m_evaluations(0),
			m_random(0)
		{
		}

		/**
		* @return
		* The current best genotype that has been found during the iterations
		*/
		Genotype best() const{
			return *m_candidates[0];
		}

		/**
		* Clear the candidate list and use the generator to generate a fixed number of genotypes
		* Do not use it between iterations, or you will lose all the previous iterations results!
		*
		* @param initialPoolSize
		*	the number of genotype to be generated
		*/
		void initialize(int initialPoolSize) {
			m_candidates.clear();
			addRandomCandidates(initialPoolSize);
		}

		/**
		* Performs a fixed number of iterations.
		* Each iteration will do successively:
		*    - add iterationAdditionalRandomGenerated randomly generated candidates
		*    - generate a mergedNumber from the merge process with two candidates that has been randomly selected
		* 	 - mutate a mutatedNumber of randomly selected candidates
		*    - evaluate all the instances quality and retain only the selectionNumber best
		* @param numberOfIterations
		* 		the number of iterations to perform
		* @param iterationAdditionalRandomGenerated
		* 		the number of fully random candidate that will be generated
		* @param selectionNumber
		*      the number of candidates that will be kept for the next iterations
		* @param mergedNumber
		* 		the number of candidate to be generated from a merge of randomly selected parents
		* @param mutatedNumber
		* 		the number of candidates to be generated by mutation of randomly selected candidates
		*/
		void iterate(int numberOfIterations, int iterationAdditionalRandomGenerated, int selectionNumber, int mergedNumber, int mutatedNumber) {
			for (int i = 0; i < numberOfIterations; i++) {
				runOneIteration(iterationAdditionalRandomGenerated, selectionNumber, mergedNumber, mutatedNumber);
			}
		}

		/**
		* Allows you to add in the candidates an already defined genotype you already know is valuable
		* Hint: this instance might come from previous iterations and you want to continue with it
		* 
		* @param reference
		*	the instance to be added to the candidate list
		*/
		void addReference(const Genotype& reference) {
			m_candidates.push_back(std::make_shared<Genotype>(reference));
		}
		/**
		* returns the number of evaluations performed so far.
		*/
		int getEvaluations() const{
			return m_evaluations;
		}
	private:

		void computeScores() {
			GenotypeScoreMap scores;

			for (const std::shared_ptr<Genotype>& candidate : m_candidates) {
				if (m_cachedScores.find(candidate)!= m_cachedScores.end()) {
					scores[candidate] =  m_cachedScores[candidate];
				}
				else {
					double score = m_fitnessFunction(*candidate);
					m_evaluations++;
					scores[candidate] = score;
					m_cachedScores[candidate] = score;
				}
			}
			m_cachedScores.clear();
			m_cachedScores = scores;
		}

		void dropUnselected(int selectionNumber) {
			m_candidates.erase(m_candidates.begin()+selectionNumber, m_candidates.end());
		}
		void addRandomCandidates(int initialPoolSize) {
			for (int i = 0; i < initialPoolSize; i++) {
				m_candidates.push_back(std::make_shared<Genotype>(m_generator()));
			}
		}

		void merge(int mergedNumber) {
			for (int i = 0; i < mergedNumber; i++) {
				int firstIndex = (2 * i) % m_candidates.size();
				int secondIndex = (2 * i + 1) % m_candidates.size();

				m_candidates.push_back(std::make_shared<Genotype>(m_merger(*m_candidates[firstIndex], *m_candidates[secondIndex])));
			}
		}

		void mutate(int mutatedNumber) {
			for (int i = 0; i < mutatedNumber; i++) {
				m_candidates.push_back(std::make_shared<Genotype>(m_mutator(*m_candidates[i])));
			}
		}

		double runOneIteration(int iterationAdditionalRandomGenerated, int selectionNumber, int mergedNumber, int mutatedNumber) {
			addRandomCandidates(iterationAdditionalRandomGenerated);
			shuffle();
			merge(mergedNumber);
			shuffle();
			mutate(mutatedNumber);
			computeScores();
			sortByScore();
			dropUnselected(selectionNumber);
			return m_cachedScores[m_candidates[0]];
		}
		void sortByScore() {
			std::sort(m_candidates.begin(), m_candidates.end(), [&](const std::shared_ptr<Genotype>& g1, const std::shared_ptr<Genotype>& g2) {
				double v1 = m_cachedScores.find(g1)->second;
				double v2 = m_cachedScores.find(g2)->second;
				
				return v1 > v2;
			});
		}
		void shuffle() {
			std::shuffle(m_candidates.begin(), m_candidates.end(), m_random);
		}
	private:
		std::function<double(const Genotype&)> m_fitnessFunction;
		std::function<Genotype()> m_generator;
		std::function<Genotype(const Genotype&, const Genotype&)> m_merger;
		std::function<Genotype(const Genotype&)> m_mutator;
		GenotypeScoreMap m_cachedScores;
		std::vector<std::shared_ptr<Genotype>> m_candidates;
		int m_evaluations;
		std::default_random_engine m_random;
	};

}}}

#endif
